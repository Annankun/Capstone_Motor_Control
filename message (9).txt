#include <stdio.h>
#include "board.h"
#include "peripherals.h"
#include "pin_mux.h"
#include "clock_config.h"
#include "fsl_debug_console.h"

// The MASK definition is crucial for setting register bits by pin number.
#define MASK(n) (1u << (n))

// Global variable for stop switch
volatile static uint8_t stop = 0;

/** INITIALIZATION FUNCTIONS ----------------------------------------------------------------------------------------- **/

void init_ports(void){
	SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTD_MASK;
	SIM->SCGC6 |= SIM_SCGC6_TPM0_MASK;		// For RGB LEDs (TPM0).
	SIM->SCGC6 |= SIM_SCGC6_TPM2_MASK;		// For motor driver (TPM2).
	SIM->SCGC6 |= SIM_SCGC6_ADC0_MASK;		// For analog input from potentiometer.
}

// Necessary for timers
void init_clock_source(void){
	SIM->SOPT2 &= ~SIM_SOPT2_TPMSRC_MASK;
	SIM->SOPT2 |= SIM_SOPT2_TPMSRC(1); // Select MCGFLLCLK or MCGPLLCLK/2
}

void init_GPIO(void){
	// Initialize the motor stop switch (B2)
	PORTB->PCR[2] &= ~PORT_PCR_MUX_MASK;
	PORTB->PCR[2] |= PORT_PCR_MUX(1);    	// GPIO mode
	PORTB->PCR[2] |= PORT_PCR_PE_MASK;   	// Enable internal pull-up/down resistor
	PORTB->PCR[2] |= PORT_PCR_PS_MASK;   	// Set internal resistor as pull-up
	PORTB->PCR[2] |= PORT_PCR_IRQC(0x0a); 	// Interrupt on falling edge (0b1010 = 0x0a)
	PTB->PDDR &= ~MASK(2);					// Set B2 as input pin.

	// Configure NVIC for the interrupt port (assuming PORTB shares PORTD IRQ for simplicity here,
    // though typically B2 uses PORTB_IRQn, the provided handler is PORTD_IRQn)
	NVIC_SetPriority(PORTD_IRQn, 128); 		// Set interrupt priority
	NVIC_ClearPendingIRQ(PORTD_IRQn);  		// Clear interrupts.
	NVIC_EnableIRQ(PORTD_IRQn); 			// Enable interrupts

	// Initialize pot GPIO (B0 - Analog)
	PORTB->PCR[0] &= ~PORT_PCR_MUX_MASK;
	PORTB->PCR[0] |= PORT_PCR_MUX(0);  // Analog mode
}

void init_RGB_LED_PWM(void){
	// Red (B18) -> TPM0_CH0 (MUX 3)
	PORTB->PCR[18] = PORT_PCR_MUX(3);
	// Green (B19) -> TMP0_CH1 (MUX 3)
	PORTB->PCR[19] = PORT_PCR_MUX(3);
	// Blue (D1) -> TMP0_CH2 (MUX 4)
	PORTD->PCR[1] = PORT_PCR_MUX(4);

	TPM0->MOD = 255;							// Set 8-bit resolution (2^8-1)
	TPM0->SC = TPM_SC_CMOD(1) | TPM_SC_PS(3); 	// Set timer to count mode (CMOD=1) and prescaler of 8 (PS=3)

	// Setup channels for Edge-aligned PWM, High-True pulses (ELSB=1, MSB=1).
	TPM0->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;
	TPM0->CONTROLS[1].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;
	TPM0->CONTROLS[2].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;

	// Set initial CnV to 255 (Max value) to turn active-low LEDs OFF initially.
	TPM0->CONTROLS[0].CnV = 255;
	TPM0->CONTROLS[1].CnV = 255;
	TPM0->CONTROLS[2].CnV = 255;
}

void init_motor_PWM(void){
	PORTA->PCR[5] = PORT_PCR_MUX(3); 			// Alternate function 3: TPM2_CH1
	PORTA->PCR[4] = PORT_PCR_MUX(3); 			// Alternate function 3: TPM2_CH0

	TPM2->MOD = 255;							// Set 8-bit resolution
	TPM2->SC = TPM_SC_CMOD(1) | TPM_SC_PS(3); 	// Set count mode CMOD and prescaler of 2^3 = 8

	TPM2->CONTROLS[1].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;
	TPM2->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;

	TPM2->CONTROLS[1].CnV = 0;				// Set all outputs low
	TPM2->CONTROLS[0].CnV = 0;
}

void init_pot_ADC(void){
	PORTB->PCR[0] &= ~PORT_PCR_MUX_MASK;
	PORTB->PCR[0] |= PORT_PCR_MUX(0);

	// Configure ADC0
	// Use default clock (bus clock), 8-bit resolution, single-ended mode
	ADC0->CFG1 = ADC_CFG1_MODE(0) |     	// 8-bit mode
	             ADC_CFG1_ADICLK(0);    	// Bus clock

	ADC0->SC1[0] = ADC_SC1_ADCH(31);    	// Disable module initially
}

/** IRQ HANDLERS -------------------------------------------------------------------------------------------------- **/
void PORTD_IRQHandler(void) {
	// A temporary indicator toggle on PTB->PDOR[0]
	PTB->PSOR = MASK(0);

	NVIC_ClearPendingIRQ(PORTD_IRQn);		// Clear pending interrupts

	if ((PORTD->ISFR & MASK(6))) {			// Check if flag for pin 6 is set
		stop = !stop;
	}
	PORTD->ISFR = 0xffffffff; 				// Clear all flags (W1TC - write 1 to clear)
	PTB->PCOR = MASK(0);
}

/** I/O CONTROL FUNCTIONS ----------------------------------------------------------------------------------------- **/

void control_RGB_LED_brightness(unsigned int r, unsigned int g, unsigned int b) {
	// On-board LEDs are active low, so CnV = 255 (OFF) - brightness value.
	TPM0->CONTROLS[0].CnV = 255 - r; 		// Red (TPM0_CH0)
	TPM0->CONTROLS[1].CnV = 255 - g;		// Green (TPM0_CH1)
	TPM0->CONTROLS[2].CnV = 255 - b;		// Blue (TPM0_CH2)
}

void control_motor_speed(uint8_t rpwm, uint8_t lpwm){
	uint8_t r_speed = (rpwm * 255) / 100;	// Calculate 8-bit PWM values
	uint8_t l_speed = (lpwm * 255) / 100;
	TPM2->CONTROLS[1].CnV = r_speed;		// Set PWM
	TPM2->CONTROLS[0].CnV = l_speed;
}

static uint8_t ADC_Read(void){
    // Start conversion on specified channel (0 corresponds to ADCH0/PTB0)
    ADC0->SC1[0] = ADC_SC1_ADCH(0);

    // Wait for conversion complete
    while (!(ADC0->SC1[0] & ADC_SC1_COCO_MASK));

    // Return result
    return ADC0->R[0];
}

// FIX: Changed input type to uint8_t and using int16_t for safe offset calculation.
void set_motor_speed(uint8_t adc_input){
	// Use int16_t for safe subtraction before casting to int8_t.
	int16_t raw_offset = (int16_t)adc_input - 128;
	int8_t offset = (int8_t)raw_offset; // Will still contain the correct signed value if raw_offset is within [-128, 127]

	if(offset >= 21 && offset < 42)control_motor_speed(20,0);
	else if(offset >= 42 && offset < 63)control_motor_speed(40,0);
	else if(offset >= 63 && offset < 84)control_motor_speed(60,0);
	else if(offset >= 84 && offset < 105)control_motor_speed(80,0);
	else if(offset >= 105 && offset <= 128)control_motor_speed(80,0);

	else if(offset <= -21 && offset > -42)control_motor_speed(20,1);
	else if(offset <= -42 && offset > -63)control_motor_speed(40,1);
	else if(offset <= -63 && offset > -84)control_motor_speed(60,1);
	else if(offset <= -84 && offset > -105)control_motor_speed(80,1);
	else if(offset <= -105 && offset >= -128) control_motor_speed(80,1);

	else control_motor_speed(0,0);
}

// FIX: Changed input type to uint8_t and using int16_t for safe offset calculation.
void set_RGB_color(uint8_t adc_input){
	// Calculate offset safely using a wider type.
	int16_t raw_offset = (int16_t)adc_input - 128;
	int8_t offset;

	// Absolute value of offset (0 to 128). Check the 16-bit offset for sign.
	if(raw_offset < 0) offset = (int8_t)(raw_offset * -1);
	else offset = (int8_t)raw_offset;

	// The color logic below should now correctly map the 0-128 absolute offset range.
	if(offset >= 21 && offset < 42) control_RGB_LED_brightness(255,255,255); // White
	else if(offset >= 42 && offset < 63)control_RGB_LED_brightness(0,255,255); // Cyan
	else if(offset >= 63 && offset < 84)control_RGB_LED_brightness(0,128,255); // Light Blue/Indigo
	else if(offset >= 84 && offset < 105)control_RGB_LED_brightness(0,255,128); // Green-Cyan
	else if(offset >= 105 && offset <= 128)control_RGB_LED_brightness(128,128,128);		// Half white brightness
	else control_RGB_LED_brightness(0,0,0); // LED off if offset is 0-20
}

/** MAIN FUNCTION  **/

int main(void) {
	init_ports();
	init_clock_source();
	init_GPIO();
	init_RGB_LED_PWM();
	init_motor_PWM();
	init_pot_ADC();

    while(1) {
        if (stop) {
            control_motor_speed(0, 0);
            control_RGB_LED_brightness(255, 0, 0);
        } else {
        	// Normal operation: Read ADC and set motor/color.
        	uint8_t adc_read = ADC_Read();
        	set_motor_speed(adc_read);
        	set_RGB_color(adc_read);
        }

        // Reduced delay for better responsiveness.
        for(int i = 10000; i > 0; i--) ;
    }
    return 0 ;
}
